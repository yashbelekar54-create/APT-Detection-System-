
input {
  file {
    path => "/opt/zeek/logs/current/*.log"
    start_position => "beginning"
    sincedb_path => "/var/lib/logstash/sincedb_zeek"
    codec => "json"
    type => "zeek"
  }
}

filter {
  if [type] == "zeek" {

    # Parse different Zeek log types
    if [path] =~ /conn\.log/ {
      mutate { add_field => { "zeek_log_type" => "connection" } }

      # Calculate connection duration
      if [duration] {
        ruby {
          code => "event.set('connection_duration_category', 
                    event.get('duration').to_f < 1 ? 'short' : 
                    event.get('duration').to_f < 60 ? 'medium' : 'long')"
        }
      }

      # Detect port scanning behavior
      if [conn_state] == "REJ" {
        mutate { 
          add_tag => ["port_scan_candidate"]
          add_field => { "threat_score" => 5 }
        }
      }

      # Detect large data transfers
      if [orig_bytes] and [orig_bytes] > 10485760 {  # > 10MB
        mutate { 
          add_tag => ["large_upload"]
          add_field => { "threat_score" => 6 }
        }
      }

      if [resp_bytes] and [resp_bytes] > 10485760 {  # > 10MB
        mutate { 
          add_tag => ["large_download"]
          add_field => { "threat_score" => 6 }
        }
      }
    }

    if [path] =~ /dns\.log/ {
      mutate { add_field => { "zeek_log_type" => "dns" } }

      # Detect DNS tunneling indicators
      if [query] {
        ruby {
          code => "
            query = event.get('query')
            if query
              # Check for suspiciously long domain names
              if query.length > 63
                event.set('dns_long_query', true)
                event.tag('dns_tunneling_candidate')
                event.set('threat_score', 7)
              end

              # Check for high entropy in subdomain (potential Base64 encoding)
              subdomains = query.split('.')
              if subdomains.length > 3
                entropy = subdomains[0].chars.group_by(&:itself).map{|c,a| p = a.size / subdomains[0].length.to_f; -p * Math.log2(p)}.sum
                if entropy > 4.5
                  event.set('dns_high_entropy', true)
                  event.tag('dns_tunneling_candidate')
                  event.set('threat_score', 8)
                end
              end
            end
          "
        }
      }

      # Detect requests for TXT records (often used in DNS tunneling)
      if [qtype_name] == "TXT" {
        mutate { 
          add_tag => ["dns_txt_request"]
          add_field => { "threat_score" => 4 }
        }
      }
    }

    if [path] =~ /http\.log/ {
      mutate { add_field => { "zeek_log_type" => "http" } }

      # Detect suspicious user agents
      if [user_agent] {
        if [user_agent] =~ /(?i)(python|curl|wget|powershell|nmap)/ {
          mutate { 
            add_tag => ["suspicious_user_agent"]
            add_field => { "threat_score" => 6 }
          }
        }
      }

      # Detect file downloads
      if [resp_mime_types] and [resp_mime_types] =~ /(executable|zip|rar|7z)/ {
        mutate { 
          add_tag => ["file_download"]
          add_field => { "threat_score" => 5 }
        }
      }
    }

    # GeoIP enrichment for external IPs
    if [id.orig_h] and [id.orig_h] !~ /^(10\.|172\.(1[6-9]|2[0-9]|3[01])\.|192\.168\.|127\.)/ {
      geoip {
        source => "id.orig_h"
        target => "orig_geo"
      }
    }

    if [id.resp_h] and [id.resp_h] !~ /^(10\.|172\.(1[6-9]|2[0-9]|3[01])\.|192\.168\.|127\.)/ {
      geoip {
        source => "id.resp_h"
        target => "resp_geo"
      }
    }

    # MITRE ATT&CK mapping for Zeek events
    if "port_scan_candidate" in [tags] {
      mutate {
        add_field => { "mitre_technique" => "T1046" }
        add_field => { "mitre_tactic" => "Discovery" }
      }
    }

    if "dns_tunneling_candidate" in [tags] {
      mutate {
        add_field => { "mitre_technique" => "T1048.003" }
        add_field => { "mitre_tactic" => "Exfiltration" }
      }
    }

    # Parse timestamp
    date {
      match => [ "ts", "UNIX" ]
      target => "@timestamp"
    }
  }
}

output {
  elasticsearch {
    hosts => ["localhost:9200"]
    index => "zeek-logs-%{+YYYY.MM.dd}"
    template_name => "zeek-template"
    template => "/etc/logstash/templates/zeek-template.json"
    template_overwrite => true
  }

  # Send high-threat network events to separate index
  if [threat_score] and [threat_score] >= 7 {
    elasticsearch {
      hosts => ["localhost:9200"]
      index => "network-threats-%{+YYYY.MM.dd}"
    }
  }
}
